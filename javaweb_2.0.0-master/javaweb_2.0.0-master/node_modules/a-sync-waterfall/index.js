// MIT license (by Elan Shanker).
(function(globals) { // 전역 객체에서 즉시 실행 함수로 시작
  'use strict'; // 엄격 모드 활성화

  var executeSync = function(){ // 동기적으로 함수 실행
    var args = Array.prototype.slice.call(arguments); // 전달된 인수들을 배열로 변환
    if (typeof args[0] === 'function'){ // 첫 번째 인수가 함수인지 확인
      args[0].apply(null, args.splice(1)); // 해당 함수 실행
    }
  };

  var executeAsync = function(fn){ // 비동기적으로 함수 실행
    if (typeof setImmediate === 'function') { // setImmediate 함수 지원 확인
      setImmediate(fn); // 지원 시 즉시 실행
    } else if (typeof process !== 'undefined' && process.nextTick) { // Node.js의 process.nextTick 확인
      process.nextTick(fn); // 지원 시 다음 틱에서 실행
    } else { // 위 조건이 모두 아닌 경우
      setTimeout(fn, 0); // 일정 시간 후 실행
    }
  };

  var makeIterator = function (tasks) { // 작업을 반복할 이터레이터 생성
    var makeCallback = function (index) { // 작업에 대한 콜백 생성
      var fn = function () { // 각 작업을 수행하는 함수
        if (tasks.length) { // 작업이 남아 있는지 확인
          tasks[index].apply(null, arguments); // 해당 작업 실행
        }
        return fn.next(); // 다음 작업으로 이동
      };
      fn.next = function () { // 다음 작업으로 이동하는 함수
        return (index < tasks.length - 1) ? makeCallback(index + 1): null; // 다음 작업이 있는 경우 새로운 콜백 생성
      };
      return fn; // 콜백 함수 반환
    };
    return makeCallback(0); // 첫 번째 작업부터 시작
  };
  
  var _isArray = Array.isArray || function(maybeArray){ // 배열인지 확인하는 함수
    return Object.prototype.toString.call(maybeArray) === '[object Array]'; // 배열 여부 확인
  };

  var waterfall = function (tasks, callback, forceAsync) { // waterfall 함수 정의
    var nextTick = forceAsync ? executeAsync : executeSync; // 동기 또는 비동기 함수 선택
    callback = callback || function () {}; // 콜백 함수가 없는 경우 기본값 설정
    if (!_isArray(tasks)) { // tasks가 배열인지 확인
      var err = new Error('First argument to waterfall must be an array of functions'); // 에러 메시지 생성
      return callback(err); // 에러 콜백 호출
    }
    if (!tasks.length) { // tasks 배열이 비어 있는지 확인
      return callback(); // 비어 있으면 콜백 호출
    }
    var wrapIterator = function (iterator) { // 이터레이터를 감싸는 함수
      return function (err) { // 에러를 처리하는 함수 반환
        if (err) { // 에러가 있는 경우
          callback.apply(null, arguments); // 에러 콜백 호출
          callback = function () {}; // 에러 후 콜백 초기화
        } else { // 에러가 없는 경우
          var args = Array.prototype.slice.call(arguments, 1); // 인수 추출
          var next = iterator.next(); // 다음 작업 가져오기
          if (next) { // 다음 작업이 있는 경우
            args.push(wrapIterator(next)); // 이터레이터를 감싸서 인수로 전달
          } else { // 다음 작업이 없는 경우
            args.push(callback); // 마지막 콜백 전달
          }
          nextTick(function () { // 다음 틱에서 실행
            iterator.apply(null, args); // 작업 실행
          });
        }
      };
    };
    wrapIterator(makeIterator(tasks))(); // 첫 번째 작업 시작
  };

  if (typeof define !== 'undefined' && define.amd) { // AMD 모듈 정의 확인
    define([], function () { // 의존성 없는 모듈 정의
      return waterfall; // waterfall 함수 반환
    }); // RequireJS
  } else if (typeof module !== 'undefined' && module.exports) { // CommonJS 모듈 확인
    module.exports = waterfall; // waterfall 함수를 모듈로 내보내기
  } else { // 둘 다 아닌 경우 (브라우저 환경)
    globals.waterfall = waterfall; // 전역 객체에 waterfall 함수 할당
  }
})(this); // 전역 객체에 즉시 실행 함수 적용
