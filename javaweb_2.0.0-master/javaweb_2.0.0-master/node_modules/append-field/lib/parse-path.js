// 첫 번째 키를 추출하기 위한 정규식
var reFirstKey = /^[^\[]*/
// 숫자 형태의 경로를 추출하기 위한 정규식
var reDigitPath = /^\[(\d+)\]/
// 일반적인 경로를 추출하기 위한 정규식
var reNormalPath = /^\[([^\]]+)\]/

/**
 * 경로를 파싱하는 함수
 * @param {string} key - 파싱할 경로
 * @returns {Object[]} - 파싱된 경로 배열
 */
function parsePath (key) {
  // 실패 시 기본값 반환
  function failure () {
    return [{ type: 'object', key: key, last: true }]
  }

  // 첫 번째 키 추출
  var firstKey = reFirstKey.exec(key)[0]
  // 첫 번째 키가 없으면 실패
  if (!firstKey) return failure()

  // 문자열 길이와 현재 위치 설정
  var len = key.length
  var pos = firstKey.length
  // 첫 번째 키에 대한 정보 생성
  var tail = { type: 'object', key: firstKey }
  var steps = [tail]

  // 문자열의 끝까지 반복하여 경로 추출
  while (pos < len) {
    var m

    // 빈 배열 표기인 경우
    if (key[pos] === '[' && key[pos + 1] === ']') {
      pos += 2
      tail.append = true
      // 문자열의 끝이 아니면 실패
      if (pos !== len) return failure()
      continue
    }

    // 숫자 형태의 경로인 경우
    m = reDigitPath.exec(key.substring(pos))
    if (m !== null) {
      pos += m[0].length
      tail.nextType = 'array'
      tail = { type: 'array', key: parseInt(m[1], 10) }
      steps.push(tail)
      continue
    }

    // 일반적인 경로인 경우
    m = reNormalPath.exec(key.substring(pos))
    if (m !== null) {
      pos += m[0].length
      tail.nextType = 'object'
      tail = { type: 'object', key: m[1] }
      steps.push(tail)
      continue
    }

    // 경로 추출 실패
    return failure()
  }

  // 마지막 키 표시
  tail.last = true
  return steps
}

// 모듈로 내보내기
module.exports = parsePath
