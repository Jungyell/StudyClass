"use strict";
module.exports = (function(){
// AssertionError 클래스 정의
var AssertionError = (function() {
    function AssertionError(a) {  
        this.constructor$(a);   // Error 클래스 상속
        this.message = a;   // 메시지 설정
        this.name = "AssertionError";   // 이름 설정
    }
     // Error 클래스 상속
    AssertionError.prototype = new Error();
    AssertionError.prototype.constructor = AssertionError;
    AssertionError.prototype.constructor$ = Error;
    return AssertionError;
})();

// 함수 매개변수 가져오기
function getParams(args) {
    var params = [];
    for (var i = 0; i < args.length; ++i) params.push("arg" + i);
    return params;
}

// 네이티브 어서션 함수
function nativeAssert(callName, args, expect) {
    try {
        var params = getParams(args);
        var constructorArgs = params;
        constructorArgs.push("return " +
                callName + "("+ params.join(",") + ");");
        var fn = Function.apply(null, constructorArgs);
        return fn.apply(null, args);
    } catch (e) {
        // SyntaxError가 아닌 경우는 예외를 다시 던지기
        if (!(e instanceof SyntaxError)) {
            throw e;
        } else {
            return expect;
        }
    }
}
// assert 함수 정의
return function assert(boolExpr, message) {
    if (boolExpr === true) return;   // 조건이 참이면 함수 종료

      // 문자열로 네이티브 호출하는 경우 처리
    if (typeof boolExpr === "string" &&
        boolExpr.charAt(0) === "%") {
        var nativeCallName = boolExpr;
        var $_len = arguments.length;var args = new Array(Math.max($_len - 2, 0)); for(var $_i = 2; $_i < $_len; ++$_i) {args[$_i - 2] = arguments[$_i];};
        // 네이티브 어서션 호출 결과가 메시지와 같으면 함수 종료
        if (nativeAssert(nativeCallName, args, message) === message) return;
        // 메시지 설정
        message = (nativeCallName + " !== " + message);
    }

    // AssertionError 인스턴스 생성
    var ret = new AssertionError(message);
    // 스택 트레이스 캡쳐
    if (Error.captureStackTrace) {
        Error.captureStackTrace(ret, assert);
    }
    // 예외 던지기
    throw ret;
};
})();
